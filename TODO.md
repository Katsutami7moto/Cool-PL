## TODO

- [ ] Modules (statements `module`, `import` (no special effect, just for visibility) and `use` (to skip full module path; the modules mustn't have anything with equal names), with correct placing of declarations and realizations)
- [ ] Appeal to module's fields/functions (and modules in directories) through dots
- [ ] All basic statements in functions
- [ ] System that will convert all math, logic and containers' operations to functions
- [ ] `func`
- [ ] `proc`
- [ ] Product types, their constructors and destructors (`del` statement)
- [ ] Choose memory management system
- [ ] Extension functions for product types
- [ ] `bool` type
- [ ] Product types with generics
- [ ] List literals
- [ ] `List` type, basic functions and behavior (`[x..y..z], list[i], list[a:b]`; List.append and others..)
- [ ] `for` loop
- [ ] Conditions `in`/`not in`, using in `if` and loops
- [ ] List comprehensions
- [ ] Char literals
- [ ] `char` type (UTF-8 !!)
- [ ] `typedef`
- [ ] String literals
- [ ] `String` type (`typedef String = List<char>;` or like that)
- [ ] Inersection types, their constructors and destructors (`del` statement)
- [ ] Extension functions for intersection types
- [ ] Intersection types with generics
- [ ] Passing intersection type value to one of its product types argument in function call
- [ ] Variant types
- [ ] Variant types with generics
- [ ] `None`
- [ ] `Option<T>` type (??)
- [ ] Passing to variant type argument in function call one of its types value
- [ ] Interfaces
- [ ] Interfaces with generics (??)
- [ ] Standart interfaces (??)
- [ ] Containers through interfaces (??)
- [ ] Nested generics
- [ ] `typedef` with generics (??)
- [ ] Implement all basic types as structures (including attribute of typename and so on)
- [ ] Expression-returning functions
- [ ] `cell`
- [ ] `cort`
- [ ] Functional programming features
- [ ] Functional type
- [ ] Lambda expressions
- [ ] `pure`
- [ ] `nest`
- [ ] Naming function parameters in call (like in Python)
- [ ] Multiple and keyword function parameters (like in Python)
- [ ] Function parameters with default values (like in Python)
- [ ] Pipe operator with just functions
- [ ] Pipe operator with module/extension functions
- [ ] Pattern matching expression
- [ ] Pattern matching statement
- [ ] Foreign functions/types interface
- [ ] IO functions
- [ ] Multiple files compilation (project configuration file)
- [ ] ...

### Where is symbol table needed (according to silv_parser):

- In checking the type of element/expression (getting type of ident-element);
- In atom parsing (external var);
- In expression parsing (making function call Token);
- In var/let parsing (checking written and writing new ones);
- In mod parsing (checking if present, if var, and proper rvalue type checking);
- In func parsing (checking written and writing new ones);
